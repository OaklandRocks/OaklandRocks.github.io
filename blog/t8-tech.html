<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css"/>
	<meta charset="UTF-8">
	<title>Technical Blog</title>
</head>
<body>
	<div class = "ruby">
		<h3>An overview of quick sort and bubble sort</h3>
		<p>
			<p>Quick sort.</p>
			<p>Quick sort is a  O(n log n) algorithm. So what does that mean?
				Baiscally all you really need to know is that it is a divide and conquer algorithm.  It first divides a large arry into smaller sub-arrys.  Then it <i>recursivly sorts the sub-arrays.</i> from the wiki page here is the pseudocode for quicksort</p>
			<ul>
				<code>quicksort(A, lo, hi):
				    <ul>if lo < hi:</ul>
				    <ul>p := partition(A, lo, hi)</ul>
				    <ul>quicksort(A, lo, p - 1)</ul>
				    <ul>quicksort(A, p + 1, hi)</ul>
				    <ul>// lo is the index of the leftmost element of the subarray
					// hi is the index of the rightmost element of the subarray (inclusive)</ul>
					 <ul>partition(A, lo, hi)</ul>
					 <ul>pivotIndex := choosePivot(A, lo, hi)</ul>
					 <ul>pivotValue := A[pivotIndex]</ul>
					 <ul>// put the chosen pivot at A[hi]</ul>
					 <ul>swap A[pivotIndex] and A[hi]</ul>
					 <ul>storeIndex := lo</ul>
					 <ul>// Compare remaining array elements against pivotValue = A[hi]</ul>
					 <ul>for i from lo to hiâˆ’1, inclusive</ul>
					     <ul>      if A[i] < pivotValue</ul>
					         <ul>swap A[i] and A[storeIndex]</ul>
					         <ul>storeIndex := storeIndex + 1</ul>
					 <ul>swap A[storeIndex] and A[hi]  // Move pivot to its final place</ul>
					 <ul>return storeIndex</ul>
				</code>
			</ul>
			<p>To better understand this we should look at it in Ruby code</p>
			<ul>
				<code>
					<ul>def quicksort(array, from=0, to=nil)</ul>
				    <ul>if to == nil</ul>
			        <ul># Sort the whole array, by default</ul>
			        <ul>to = array.count - 1</ul>
				    <ul>end</ul>
				    <ul>if from >= to</ul>
				        <ul># Done sorting</ul>
				        <ul>return array</ul>
				    <ul>end</ul>

    <ul># Take a pivot value, at the far left</ul>
    <ul>pivot = array[from]</ul>

    <ul># Min and Max pointers</ul>
    <ul>min = from</ul>
    <ul>max = to</ul>

    <ul># Current free slot</ul>
    <ul>free = min</ul>

    <ul>while min < max</ul>
        <ul>if free == min # Evaluate array[max]</ul>
            <ul>if array[max] <= pivot # Smaller than pivot, must move</ul>
               <ul> array[free] = array[max]</ul>
                <ul>min += 1</ul>
                <ul>free = max</ul>
            <ul>else</ul>
                <ul>max -= 1</ul>
            <ul>end</ul>
        <ul>elsif free == max # Evaluate array[min]</ul>
            <ul>if array[min] >= pivot # Bigger than pivot, must move</ul>
                <ul>array[free] = array[min]</ul>
                <ul>max -= 1</ul>
                <ul>free = min</ul>
            <ul>else</ul>
                <ul>min += 1</ul>
            <ul>end</ul>
        <ul>else</ul>
            <ul>raise "Inconsistent state"</ul>
        <ul>end</ul>
    <ul>end</ul>

   <ul> array[free] = pivot</ul>

    <ul>quicksort array, from, free - 1</ul>
    <ul>quicksort array, free + 1, to</ul>
<ul>end</ul>
				
			</code>

		</ul>
			<ul>bubble sort in JS</ul>
		</p>
		<ul>function bubbleSort()</ul>
<ul>{</ul>
  <ul>var didSwap = true;</ul>
  <ul>while(didSwap){</ul>
    <ul>didSwap = false;</ul>
    <ul>for (var i=0; i < this.length-1; i++) {</ul>
      <ul>if (this[i] > this[i+1]) {</ul>
        <ul>var temp = this[i];</ul>
        <ul>this[i] = this[i+1];</ul>
        <ul><this[i+1] = temp;/ul>
        <ul>didSwap = true;</ul>
      <ul>}</ul>
    <ul>}</ul>
  <ul>}</ul>
<ul>}</ul>

	</div>
</body>
</html>